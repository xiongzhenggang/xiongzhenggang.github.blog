## numpy花式索引Fancy indexing 

前面的部分中，我们看到了如何使用简单索引（例如arr [0]），切片（例如arr [：5]）和布尔掩码（例如arr [arr> 0]）访问和修改数组的部分）。
本节中，我们将介绍另一种样式的数组索引，称为花式索引。花式索引就像我们已经看到的简单索引一样，但是我们传递索引数组来代替单个标量。这使我们能够非常快速地访问和修改数组值的复杂子集。

### 探索花式索引
 从概念上讲，花式索引就是向数组传递一个索引数组，来一次获取数组中多个元素
```py
In [1]: import numpy as np
In [2]: rand=np.random.RandomState(0)
In [3]: x=rand.randint(10,size=10)
In [4]: x
Out[4]: array([5, 0, 3, 3, 7, 9, 3, 5, 2, 4])
```

 假设我们要访问三个不同的元素。我们可以这样做：
 ```py
In [6]: [x[3], x[7], x[2]]
Out[6]: [3, 5, 3]
 ```
使用花式索引
```py
In [7]: ind=[3,7,2]
In [8]: x[ind]
Out[8]: array([3, 5, 3])
```
* 使用花式索引时，结果的形状反映索引数组的形状，而不是原数组的形状：
```py
In [9]: ind2=np.array([[1,2],[4,5]])
In [10]: x[ind2]
Out[10]: 
array([[0, 3],
       [7, 9]])
```
花式索引也能作用于多维数组
```py
In [11]: x=np.arange(9).reshape((3,3))
In [12]: x
Out[12]: 
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])

In [13]: rowInd = np.array([1,2])
In [14]: colInd=np.array([0,1])
In [15]: x[rowInd,colInd]
# 取x下标1，0 和2，1 
Out[15]: array([3, 7])
```
* 花式索引中的索引配对遵循“阵列计算：广播”中提到的所有广播规则。所以，例如，如果我们在索引内合并列向量和行向量，则会得到二维结果：
```py
# 此时rowInd[:,np.newaxis]和colInd会根据广播的规则做扩展=》形成[[1,1],[2,2]] 和[[0,1],[0,1]]
In [16]: x[rowInd[:,np.newaxis],colInd]
Out[16]:
# 取值第一行下标1,0 1,1 第二行 2，0 2，1
array([[3, 4],
       [6, 7]])
```
### 组合索引
对于更强大的操作，可以将花式索引与我们已经看到的其他索引方案结合使用：
```py
In [29]: x
Out[29]: 
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
#所以第二行在使用花式索引选取0，1列
In [30]: x[2,[0,1]]
Out[30]: array([6, 7])
```

```py
In [31]: mask = np.array([1, 0, 1], dtype=bool)
In [43]: x[rowInd[:,np.newaxis],mask]
Out[43]: 
array([[3, 5],
       [6, 8]])
```

### 示例：选择随机点
fancy index的一种常见用法是从矩阵中选择行的子集。例如，我们可能有一个N x D矩阵，表示D维中的N个点，例如从二维正态分布中得出的以下点：
```py
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
import numpy as np
import matplotlib.pyplot as plt
import seaborn; 
seaborn.set()  # for plot styling
mean = [0, 0]
cov = [[1, 2],
       [2, 5]]
# mean：均值，必选参数；
# cov：协方差矩阵，必选参数；
# size： 指定生成矩阵的维度，若size=(1, 1, 2)，则输出的矩阵的 shape 即形状为 1X1X2XN（N为mean的长度）；
# check_valid：可取值 warn，raise以及ignore；
# tol：检查协方差矩阵奇异值时的公差，float类型；
X = np.random.multivariate_normal(mean, cov, 100)
print(X.shape)
plt.scatter(X[:, 0], X[:, 1]);
plt.show()
```
使用我们将在Matplotlib将这些点可视化为散点图：

![图片.png](https://github.com/xiongzhenggang/xiongzhenggang.github.io/blob/master/data-science/image/scatter_plot.png)
